#+TITLE:      Redis

* 目录                                                    :TOC_4_gh:noexport:
- [[#安装与配置][安装与配置]]
- [[#数据类型概览][数据类型概览]]
- [[#单线程和原子性][单线程和原子性]]
- [[#分布式锁][分布式锁]]
- [[#相关技巧][相关技巧]]
- [[#相关问题][相关问题]]
  - [[#如果-redis-没有设置-expire它是否默认永不过期][如果 redis 没有设置 expire，它是否默认永不过期？]]

* 安装与配置
  + 安装指令：
    #+BEGIN_SRC bash
      apt-get install redis-server
    #+END_SRC

  + 配置外网访问：
    1. 注释掉 ~/etc/redis/redis.conf~ 中的 ~bind~ 配置项
    2. 配置安全组允许 ~6739~ 端口的访问
    3. 设置客户端的访问密码
       #+BEGIN_SRC bash
         $ redis-cli
         > CONFIG SET requirepass <password>
         > exit

         $ redis-cli
         > AUTH <password>
       #+END_SRC
    4. 重启服务
       #+BEGIN_SRC bash
         $ service redis-server restart
       #+END_SRC

* 数据类型概览
  |----------+----------+--------------------------------------------+-----------------------------------|
  | 数据类型 | 存取指令 | 实际例子                                   | 注意事项                          |
  |----------+----------+--------------------------------------------+-----------------------------------|
  | String   | SET      | SET name "name"                            | 一个键最大能存储 512MB            |
  |          | GET      | GET name                                   |                                   |
  |----------+----------+--------------------------------------------+-----------------------------------|
  | Hash     | HMSET    | HMSET myhash field1 "Hello" field2 "World" | 每个 hash 可以存储 2^32 -1 键值对 |
  |          | HGET     | HGET myhash field1                         |                                   |
  |----------+----------+--------------------------------------------+-----------------------------------|
  | List     | LPUSH    | LPUSH runoob redis                         | 列表最多可存储 2^32 - 1 元素      |
  |----------+----------+--------------------------------------------+-----------------------------------|
  | Set      | SADD     | SADD key member                            | 集合中最大的成员数为 2^32 - 1     |
  |----------+----------+--------------------------------------------+-----------------------------------|
  | Zset     | ZADD     | ZADD key score member                      | 有序集合根据 score 进行排序       |
  |----------+----------+--------------------------------------------+-----------------------------------|
  
* 单线程和原子性
  Redis 在 4.0 以前的版本是单线程的，而 4.0 之后的版本，虽然引入了多线程，单也只是针对部分指令，核心依然是单线程的。

  6.0 之后引入了新的多线程在网络 I/O 部分，但是命令的执行依然在主线程中，单个/批指令的指令依然可以看作原子的。

  参考：
  + [[https://draveness.me/whys-the-design-redis-single-thread/][为什么 Redis 选择单线程模型 - 面向信仰编程]]
  + [[https://mp.weixin.qq.com/s/-op5WR1wSkgAuP7JYZWP8g][Redis 多线程网络模型全面揭秘]]
  
* 分布式锁
  分布式锁的基本思想其实很简单，就是在一个中间服务上判断一个 key 存不存在，不存在就加锁，需要保证这两步操作的原子性。

  而借助 Redis 执行 Lua 脚本时的原子性，当一个服务来获取锁时，就执行一段 Lua 脚本，取锁成功就设置一个值到 Redis 中，取锁失败返回空值。

  这是对于单个 Redis 服务来说的，但要是 Redis 集群呢？那我们可以遍历集群中的每一个 Redis 服务！

  参考：
  + [[https://juejin.im/post/5b737b9b518825613d3894f4#heading-15][Redis 系列：分布式锁 - 掘金]]

* 相关技巧 
  + 通过指令 ~SELECT~ 切换数据库，默认为 ~0~
    #+BEGIN_SRC bash
      redis 127.0.0.1:6379> SET db_number 0         # 默认使用 0 号数据库
      OK

      redis 127.0.0.1:6379> SELECT 1                # 使用 1 号数据库
      OK

      redis 127.0.0.1:6379[1]> GET db_number        # 已经切换到 1 号数据库，注意 Redis 现在的命令提示符多了个 [1]
      (nil)

      redis 127.0.0.1:6379[1]> SET db_number 1
      OK

      redis 127.0.0.1:6379[1]> GET db_number
      "1"

      redis 127.0.0.1:6379[1]> SELECT 3             # 再切换到 3 号数据库
      OK

      redis 127.0.0.1:6379[3]>                      # 提示符从 [1] 改变成了 [3]
    #+END_SRC

  + Redis 中 Key 可以是任何安全的二进制序列，这意味着用图片做键也是可以的，因此，可以有如下形式的键：
    #+BEGIN_EXAMPLE
      user:1000
    #+END_EXAMPLE

    参考：[[https://redis.io/topics/data-types-intro][An introduction to Redis data types and abstractions – Redis]]

* 相关问题
  redis 中 set xxx expire 时的时间单位：秒

** 如果 redis 没有设置 expire，它是否默认永不过期？
   来自大佬的回答：
   #+begin_quote
   Redis 无论有没有设置 expire，它都会遵循 redis 的配置好的删除机制，在配置文件里设置：Redis 最大内存不足时的数据清除策略，默认为 "volatile-lru"。
   + volatile-lru    -> 对“过期集合”中的数据采取 LRU(近期最少使用)算法。如果对 key 使用 “expire” 指令指定了过期时间,那么此 key 将会被添加到“过期集合”中。将已经过期 LRU 的数据优先移除。如果“过期集合”中全部移除仍不能满足内存需求，将 OOM。
   + allkeys-lru     -> 对所有的数据，采用 LRU 算法
   + volatile-random -> 对“过期集合”中的数据采取“随即选取”算法，并移除选中的 K-V，直到“内存足够”为止。如果如果“过期集合”中全部移除全部移除仍不能满足，将 OOM
   + allkeys-random  -> 对所有的数据，采取“随机选取”算法，并移除选中的K-V，直到“内存足够”为止
   + volatile-ttl    -> 对“过期集合”中的数据采取 TTL 算法(最小存活时间)，移除即将过期的数据。
   + noeviction      -> 不做任何干扰操作，直接返回 OOM 异常
   #+end_quote

   参考：
   + [[https://segmentfault.com/q/1010000004490914][如果redis没有设置expire，他是否默认永不过期？ - SegmentFault 思否]]


