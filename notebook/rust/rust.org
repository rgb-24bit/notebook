#+TITLE:      Rust

* 目录                                                    :TOC_4_gh:noexport:
- [[#patterns-and-matching][Patterns and Matching]]
- [[#smart-pointers][Smart Pointers]]

* Patterns and Matching
  Rust 中模式匹配是一个很常用也很强大的功能，本质上，通过 let 绑定变量也是一种模式匹配，函数参数也是一种隐式 let 绑定。

  详细的语法可参考：
  + [[https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html][Pattern Syntax - The Rust Programming Language]]
  + [[https://doc.rust-lang.org/stable/reference/patterns.html][Patterns - The Rust Reference]]

  这里记录一下有关于 ref 模式在 2015 和 2018 下不同引发的困惑：
  1. 在官方文档中，Rust 2015 不能自动推断 ref，所以会存在下面形式的代码：
     #+begin_src rust
       // Rust 2015

       let s: &Option<String> = &Some("hello".to_string());

       match s {
           &Some(ref s) => println!("s is: {}", s),
           _ => (),
       };
     #+end_src

     这里，&Some 匹配 &Option 类型，而 ref s 用于创建变量的引用。

  2. 在 Rust 2018 中，则可以写成下面的形式：
     #+begin_src rust
       let s: &Option<String> = &Some("hello".to_string());

       match s {
           Some(s) => println!("s is: {}", s),
           _ => (),
       };
     #+end_src

  简单来说，在 Rust 2018 中，对于 &Enum::Type(ref x) 类型的匹配，可以直接写成 Enum::Type：
  #+begin_src rust
    let v1: Option<i32> = Some(3);
    match v1 {
        Some(x) => println!("{}", x),  // x is i32
        None => println!("None"),
    }

    let v2: Option<i32> = Some(3);
    match &v1 {
        Some(x) => println!("{}", x),  // x is &i32
        None => println!("None"),
    }
  #+end_src

  参考：
  + [[https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html][Default match bindings - The Edition Guide]]
  + [[https://doc.rust-lang.org/rust-by-example/scope/borrow/ref.html][The ref pattern - Rust By Example]]

* Smart Pointers
  当某个类型 T 实现了 Deref<Target=U> 时，我们可以将 &T 当作 &U 来使用，Rust 可以自动完成隐式的类型转换。

  与之相应的还有 DerefMut 这个 trait，允许我们将 &mut T 当作 &mut U 来使用。

  trait 定义：
  #+begin_src rust
    pub trait Deref {
        type Target: ?Sized;
        #[must_use]
        pub fn deref(&self) -> &Self::Target;
    }

    pub trait DerefMut: Deref {
        pub fn deref_mut(&mut self) -> &mut Self::Target;
    }
  #+end_src

  具体的规则：
  #+begin_quote
  + From &T to &U when T: Deref<Target=U>
  + From &mut T to &mut U when T: DerefMut<Target=U>
  + From &mut T to &U when T: Deref<Target=U>
  #+end_quote

  例子：
  #+begin_src rust
    let box_i32 = Box::new(0i32);       // Box<T>, Deref<Target=T>, &Box => &T
    let ref_i32: &i32 = &box_i32;
    let val_i32: i32 = *box_i32;

    let slice: &[u8] = &vec![0u8];      // Vec<T>, Deref<Target=[T]>, &Vec => &[]
    let s: &str = &String::from("0");   // String, Deref<Target=str>, &String => &str
  #+end_src
  
  参考：
  + [[https://doc.rust-lang.org/book/ch15-02-deref.html#how-deref-coercion-interacts-with-mutability][Treating Smart Pointers Like Regular References with the Deref Trait - The Rust Programming Language]]

