#+TITLE:      操作系统 - 程序的机器级表示

* 目录                                                    :TOC_4_gh:noexport:
- [[#att-与-intel-汇编代码格式][ATT 与 Intel 汇编代码格式]]
- [[#数据格式][数据格式]]
  - [[#寄存器][寄存器]]
  - [[#操作数指示符][操作数指示符]]
- [[#mov-指令][MOV 指令]]
- [[#pop-和-push-指令][POP 和 PUSH 指令]]
- [[#算数和逻辑操作][算数和逻辑操作]]
  - [[#加载有效地址][加载有效地址]]
  - [[#一元和二元操作][一元和二元操作]]
  - [[#移位操作][移位操作]]
- [[#控制][控制]]
  - [[#条件码][条件码]]
  - [[#cmp--test][CMP & TEST]]
  - [[#访问条件码][访问条件码]]
  - [[#跳转指令][跳转指令]]
  - [[#跳转表][跳转表]]
- [[#过程][过程]]
  - [[#数据传送][数据传送]]
- [[#数组的分配和访问][数组的分配和访问]]
  - [[#指针运算][指针运算]]
  - [[#嵌套的数组][嵌套的数组]]
  - [[#变长数组][变长数组]]
- [[#异质的数据结构][异质的数据结构]]
  - [[#结构体][结构体]]
  - [[#联合][联合]]
  - [[#数据对齐][数据对齐]]

* ATT 与 Intel 汇编代码格式
  对比 ~ATT~ 格式， ~Intel~ 汇编代码格式做出了这些修改：
  1. 省略了指示大小的后缀
  2. 省略了寄存器前面的 ~%~ 符号
  3. 用不同的方式来描述内存中的位置， 如 ~QWORD PTR [rbx]~ 而不是 ~(%rbx)~
  4. 带有多个操作数的时候， 操作数的顺序和 ~ATT~ 格式相反
     
* 数据格式
  |--------------------+--------------+------------|
  | Intel 数据类型     | 汇编代码后缀 | 大小(字节) |
  |--------------------+--------------+------------|
  | ~字节(byte)~         | ~b~            | ~1~          |
  | ~字(word)~           | ~w~            | ~2~          |
  | ~双字(double words)~ | ~l~            | ~4~          |
  | ~四字(quad words)~   | ~q~            | ~8~          |
  |--------------------+--------------+------------|

  *PS:* 双字后缀 ~l~ 可以按 长字 ~long word~ 来理解。

** 寄存器
   + 完整寄存器列表： *P120*
   + 两个规则：
     1. 生成 1 字节和 2 字节数字的指令会保持剩下的字节不变
     2. 生成 4 字节数字的指令会把高位 4 个字节置为 0
   + 栈指针寄存器 ~%rsp~
   + 基址指针(帧指针)寄存器 ~%rbp~
   + PC ~%rip~

** 操作数指示符
   1. 立即数(immediate), 书写方式为 ~$~ 后面跟一个用标准 C 表示法表示的整数， 如 ~$123~, ~$-123~
   2. 寄存器(register), 书写方式为 ~%~ 跟一个寄存器名， 如 ~%rax~, ~%eax~
   3. 内存引用， 书写方式为 ~立即数(基址寄存器 A, 变址寄存器 B, 比例因子 S)~.
      其中 ~s~ 必须为 ~1, 2, 4, 8~ 中的一个。 寄存器必须为 ~64~ 位寄存器。

      有效地址的值为： ~立即数 + 基址寄存器的值 + 变址寄存器的值 * 比例因子~.

      各部分为可选参数， 即这些都是有效的内存引用： *0xFFFF*, *(%rax)*, *(%rax, %rbx)*, *(%rax, %rbx, 1)*...

* MOV 指令
  + /movb, movw, movl, movl, movabsq/.
  + *movabsq* 以任意 64 位立即数作为源操作数， 以寄存器作为目标操作数
  + *movl* 以寄存器作为目标时， 会把该寄存器的高位 4 字节置为 0

  注意事项：
  + 不能直接将一个值从内存 *MOV* 到内存， 正确的顺序为 *内存 --> 寄存器 --> 内存*
  + 如果操作数中存在寄存器， 那么操作数的后缀必须与指定的寄存器大小相匹配
  + 如果两个操作数都是寄存器， 那么两个寄存器的大小必须相同

  将较小的源值复制到较大的目的：
  + *MOVZ* 类指令把目标中剩余的字节填充为 0
  + *MOVS* 类指令通过 *符号扩展* 来填充， 把源操作数的最高位进行复制

  完整指令列表： P121

  指令举例： *movzbl*, 将 *字节 b* 传送到 *双字 l*

* POP 和 PUSH 指令
  + *pushq* 指令, 栈顶地址减 8, 存入操作数的值. 操作数可以是 *立即数*, *寄存器*, *内存*. *寄存器* 大小没有要求
  + *popq* 指令, 返回栈顶数据, 栈顶地址加 8. 操作数可以是 *寄存器*, *内存*. *寄存器* 大小没有要求
  + 弹入和弹出的数据大小都是 *四字(8 byte)*

  栈向下增长， 堆向上增长：
  #+BEGIN_SRC C
    #include <stdio.h>
    #include <stdlib.h>

    int main(int ragc, char* argv[]) {
      int a = 10;
      int b = 10;
      int* heap = (int*)malloc(10 * sizeof(int));

      printf("a: %p, b: %p\n", &a, &b);
      for (int i = 0; i < 10; ++i) {
        printf("heap[%d]: %p\n", i, &heap[i]);
      }

      return 0;
    }
  #+END_SRC

* 算数和逻辑操作
** 加载有效地址  
   加载有效地址 ~LEA~, 是 ~MOV~ 指令的变性， 计算出 *地址* 的值， 但不读取
   *地址* 的值， 而是直接将 *地址* 的值送人 *目标操作数*.

** 一元和二元操作
   一元操作， D 既是源又是目的：
   + INC D 加 1
   + DEC D 减 1
   + NEG D 取反加 1
   + NOT D 按位取反
   二元操作， D 既是源又是目的：
   + ADD S D 加 S
   + SUB S D 减 S
   + IMUL S D 乘 S
   + XOR S D 和 S 进行异或运算
   + OR S D 和 S 进行或运算
   + AND S D 和 S 进行与运算

** 移位操作
   对于移位操作， 算数左和逻辑左移的操作是一样的， 在右端补 0.

   而逻辑右移是在左端补 0, 算数右移是补 *符号位*.

   移位操作的目标操作数可以是寄存器或内存位置。
   
   + 指令 移位量, 目标操作数
   + SAL, SHL, 左移
   + SAR 算数右移
   + SHR 逻辑右移

* 控制
** 条件码
   + [[https://en.wikipedia.org/wiki/FLAGS_register][维基百科]]
   + CF: 进位标志， 无符号操作溢出时为 1
   + ZF: 零标志， 结果为 0 时 为 1
   + SF: 符号标志， 等于结果的最高位
   + OF: 溢出标志， 有符号数运算溢出时为 1

  不同操作对条件码的影响：
  + leaq 不改变条件码
  + 逻辑操作， 如 XOR 会将 CF 和 OF 置为 0
  + 对于移位操作， CF 会被设置为最后一个被移出的位， OF 设置为 0
  + INC 和 DEC 会设置 OF 和 ZF, 但不会改变标志位

** CMP & TEST
   + CMP 指令类似于指令 SUB, 只影响条件码， 不改变操作数的值
   + TEST 指令类似于指令 AND, 只影响条件码， 不改变操作数的值
   
** 访问条件码
   可以通过 SET 指令来访问

** 跳转指令
   + 直接跳转： 形如 ~jmp .L1~ 的形式， 跳转目标是作为指令的一部分编码的
   + 间接跳转： 形如 ~*%rax~ 的形式， 符号 ~*~ 后跟一个 *操作数指示符*. 根据
     *操作数指示符* 的值来确定跳转目标

   跳转指令： [[http://www.penguin.cz/~literakl/intel/j.html][JXX - Jump Instructions Table]]

** 跳转表
   对于 ~switch~ 语句， 当选项超过 4, 且选项之间的值 *很接近* 的时候， 编译器会
   生成一个 *跳转表*.

   需要注意的是， 跳转表的索引顺序是 ~0, 1, 2, 3...~ 而不是 ~1, 2, 3, ...~
 
* 过程
  栈向下生长， 堆向上生长。

  调用者栈帧包括： 返回地址， 函数参数
  
  被调用者栈帧包括： 旧 ~%rbp~ 的值

  + 指令 call 将其后的指令的地址压入栈， 并将 PC 的值设置为目标操作数的值。

    目标操作数可以是 *直接引用* 或 *间接引用*.

  + 指令 ret 从栈中弹出地址， 并把 PC 设置为弹出的地址值

  + 函数返回值通过寄存器传递

** 数据传送
   当寄存器够用是， 函数参数通过寄存器传递， 当函数参数的数量超过
   可用的寄存器数量， 那么函数参数就会通过 栈 传递。

   通过栈传递参数是， 所有数据大小都像地址宽度的倍数对齐， 即： 一个参数
   最少占用一个地址宽度大小的内存。

   参数在栈中的顺序： [[http://www.cnblogs.com/xkfz007/archive/2012/03/27/2420158.html][C语言中函数参数入栈的顺序]]

* 数组的分配和访问   
  类似 ~T A[N];~ 的声明， 有如下效果：
  + 在内存中分配一个 ~L·N~ 字节的连续区域， ~L~ 数据类型 ~T~ 的大小
  + 引入了标识符 ~A~, 可以用 ~A~ 作为指向数组开头的指针

** 指针运算
   + 操作符 ~*~ 产生间接引用指针
   + 操作符 ~&~ 参数指针
   + 表达式 ~Expr~ 和 ~*&Expr~ 等价
   + 计算同一个数据类型的两个指针的差， 结果等于两个地址之差 *除* 以该数据类型的大小

** 嵌套的数组
   对于 ~T D[R][C]~, 元素 ~&D[i][j]~ 的地址为： ~D + L(C·i + j)~

** 变长数组
   如果函数的参数为变长数组， 那么需要用如下的定义方式：
   #+BEGIN_SRC C
     int var_ele(long n, int A[n][n], long i, long j)
   #+END_SRC

   需要事先声明数组宽度 ~n~

* 异质的数据结构
** 结构体
   *结构体* 占据的内存大小至少为内部所有字段大小的和。

   访问结构体的字段通过 *字节偏移* 完成， 其中第一个字段的 *字节偏移* 为 0.

** 联合
   *联合* 占据的内存大小为内部最大字段的大小。

   所有字段的 *字节偏移* 都是 0, 访问不同字段是读取的内存大小不同。

   在这种情况下。 *字节顺序* 带来的影响就很大了。

** 数据对齐
   当 CPU 访问正确对齐的数据时，它的运行效率最高，当数据大小的数据模数的内存地址是 0 时，数据是对齐的。

   即：数据对齐的原则是任何 K 字节的基本对象的地址必须是 K 的整数倍。

   [[file:../c-c++/c.org::*结构体字段内存对齐][☞ 结构体字段内存对齐]]
   
   参考：
   + [[https://www.cnblogs.com/bakari/archive/2012/08/27/2658956.html][数据对齐详解 - 猿大白 - 博客园]]

